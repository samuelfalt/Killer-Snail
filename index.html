<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Chaser Map</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    :root {
      --bg: #0b1623;
      --panel: #0f2238;
      --accent: #22c55e;
      --text: #e6f0ff;
      --muted: #9fb3c8;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(120% 120% at 20% 20%, #123055, #0b1623 55%);
      color: var(--text);
      min-height: 100vh;
      display: grid;
      grid-template-rows: auto 1fr;
    }
    header {
      padding: 18px 20px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: linear-gradient(90deg, #0f2238, rgba(15, 34, 56, 0.75));
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.35);
    }
    h1 {
      margin: 0;
      font-size: 18px;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      color: var(--text);
    }
    .controls {
      display: flex;
      align-items: center;
      gap: 10px;
      color: var(--muted);
      font-size: 14px;
      padding: 6px 10px;
      background: rgba(255, 255, 255, 0.04);
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      flex-wrap: wrap;
    }
    .controls input[type="range"] {
      accent-color: var(--accent);
    }
    .btn {
      padding: 7px 12px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: linear-gradient(135deg, rgba(34, 197, 94, 0.16), rgba(34, 197, 94, 0.38));
      color: var(--text);
      font-weight: 600;
      cursor: pointer;
      transition: transform 120ms ease, box-shadow 120ms ease;
    }
    .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.25);
    }
    .snail-icon {
      font-size: 34px;
      line-height: 1;
      text-align: center;
      filter: drop-shadow(0 4px 8px rgba(0,0,0,0.35));
      user-select: none;
    }
    .status {
      margin: 0;
      font-size: 14px;
      color: var(--muted);
    }
    .pill {
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(34, 197, 94, 0.15);
      color: var(--accent);
      font-weight: 600;
      letter-spacing: 0.02em;
      border: 1px solid rgba(34, 197, 94, 0.35);
    }
    #map {
      width: 100%;
      height: calc(100vh - 70px);
      filter: drop-shadow(0 10px 30px rgba(0,0,0,0.35));
    }
    .overlay {
      position: fixed;
      inset: 70px 0 0 0;
      background: rgba(11, 22, 35, 0.9);
      backdrop-filter: blur(10px);
      display: grid;
      place-items: center;
      z-index: 10;
      padding: 24px;
    }
    .overlay.hidden { display: none; }
    .overlay.full {
      inset: 0;
      padding-top: 80px;
    }
    .panel {
      width: min(900px, 96vw);
      background: rgba(15, 34, 56, 0.9);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 20px;
      padding: 22px 22px 18px;
      box-shadow: 0 25px 60px rgba(0,0,0,0.45);
    }
    .panel h2 {
      margin: 0 0 10px;
      letter-spacing: 0.02em;
      font-size: 20px;
    }
    .choice-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 12px;
      margin: 14px 0 10px;
    }
    .card {
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 14px;
      padding: 12px;
      cursor: pointer;
      transition: transform 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
    }
    .card:hover { transform: translateY(-2px); border-color: rgba(34, 197, 94, 0.5); }
    .card.active {
      border-color: rgba(34,197,94,0.9);
      box-shadow: 0 12px 28px rgba(0,0,0,0.28);
    }
    .card .emoji { font-size: 28px; display: block; }
    .card .name { font-weight: 700; margin: 6px 0 2px; }
    .card .speed { color: var(--muted); font-size: 13px; }
    .start-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-top: 6px;
      flex-wrap: wrap;
    }
    .start-btn {
      padding: 10px 16px;
      border-radius: 12px;
      border: none;
      background: linear-gradient(135deg, #22c55e, #16a34a);
      color: #0b1623;
      font-weight: 800;
      letter-spacing: 0.02em;
      cursor: pointer;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.32);
      transition: transform 120ms ease, box-shadow 120ms ease;
    }
    .start-btn:hover { transform: translateY(-2px); box-shadow: 0 12px 32px rgba(0,0,0,0.36); }
    #message {
      position: fixed;
      bottom: 14px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(15, 34, 56, 0.95);
      color: var(--text);
      padding: 10px 14px;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.38);
      font-size: 14px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      max-width: 90vw;
    }
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Chaser Map</h1>
      <p class="status" id="status">Waiting for location permission‚Ä¶</p>
    </div>
    <div class="controls">
      <label for="speed">Chaser speed</label>
      <input id="speed" type="range" min="0" max="10" step="0.5" value="2" aria-label="Chaser speed in km per hour" />
      <span id="speed-value">2.0</span><span>km/h</span>
      <button id="restart-snail" class="btn" type="button">Reset</button>
      <button id="open-selection" class="btn" type="button">Menu</button>
      <button id="open-settings" class="btn" type="button">Settings</button>
      <button id="leave-room" class="btn" type="button" style="display:none;">Leave room</button>
    </div>
    <div style="display:flex; gap:8px; align-items:center;">
      <div class="pill" id="pill">Idle</div>
      <div class="pill" id="room-pill" style="display:none;">No room</div>
    </div>
  </header>
  <div id="map" role="region" aria-label="Map showing your location"></div>
  <div class="overlay" id="start-overlay">
    <div class="panel">
      <h2>Select mode</h2>
      <div class="start-row" id="mode-row">
        <div style="display:flex; gap:10px; flex-wrap:wrap;">
          <button id="mode-solo" class="btn" type="button">Solo</button>
          <button id="mode-room" class="btn" type="button">Multiplayer</button>
        </div>
        <p class="status" id="room-status">Choose a mode</p>
      </div>
      <div id="solo-section" style="display:none;">
        <h3>Choose your chaser</h3>
        <div class="choice-grid" id="character-grid"></div>
        <p class="status" id="selected-label">Selected: Snail ¬∑ 0.048 km/h</p>
        <div class="start-row">
          <button id="start-btn" class="start-btn" type="button">Start chase</button>
        </div>
      </div>
      <div id="room-section" style="display:none;">
        <div class="card">
          <div class="name">Multiplayer</div>
          <div class="speed" style="margin-bottom:6px;">Create a room once (max 10 players) or join with a code.</div>
          <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-bottom:8px;">
            <button id="generate-room" class="btn" type="button">Create room</button>
            <span class="status">Code:</span>
            <span id="room-code-display" class="pill" style="background:rgba(34,197,94,0.2); border-color:rgba(34,197,94,0.5);">----</span>
          </div>
          <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
            <label class="status" for="join-code">Join with code</label>
            <input id="join-code" type="text" placeholder="Enter code" maxlength="8" style="padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.1); background:rgba(255,255,255,0.05); color:var(--text);" />
            <button id="join-room" class="btn" type="button">Join room</button>
          </div>
          <div style="margin-top:10px;">
            <button id="refresh-rooms" class="btn" type="button">Refresh rooms</button>
            <div id="rooms-list" class="choice-grid" style="margin-top:8px;"></div>
          </div>
          <div class="start-row" id="room-start-row" style="display:none;">
            <p class="status">Host can start the chase when ready.</p>
            <button id="room-start-btn" class="start-btn" type="button">Start chase</button>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div class="overlay full hidden" id="lose-overlay">
    <div class="panel">
      <h2>Game over</h2>
      <p class="status" id="lose-details">The chaser caught you.</p>
      <div class="start-row">
        <button id="reset-game" class="start-btn" type="button">Reset game</button>
      </div>
    </div>
  </div>
  <div class="overlay hidden" id="settings-overlay">
    <div class="panel">
      <h2>Settings</h2>
      <div class="choice-grid" style="grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));">
        <div class="card">
          <div class="name">God mode</div>
          <label><input id="god-toggle" type="checkbox" /> Enable god mode</label>
          <div style="margin-top:8px;">
            <label for="god-speed" class="speed">God speed (km/h)</label><br />
            <input id="god-speed" type="number" min="0" max="10000" step="10" value="100" style="width: 120px;" />
          </div>
        </div>
        <div class="card">
          <div class="name">Spawn radius</div>
          <label for="spawn-radius" class="speed">Max radius (m)</label><br />
          <input id="spawn-radius" type="number" min="100" max="50000" step="100" value="5000" style="width: 130px;" />
          <div style="margin-top:8px;">
            <label><input id="random-spawn" type="checkbox" /> Randomize within radius</label>
          </div>
        </div>
      </div>
      <div class="start-row">
        <p class="status">Apply to use new settings.</p>
        <div style="display:flex; gap:10px;">
          <button id="settings-cancel" class="btn" type="button">Cancel</button>
          <button id="settings-apply" class="start-btn" type="button">Apply</button>
        </div>
      </div>
      <div style="margin-top:10px;">
        <label class="status">Player name</label>
        <input id="player-name" type="text" maxlength="24" placeholder="Leave empty for 'You'" style="padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.1);background:rgba(255,255,255,0.05);color:var(--text);width:100%;" />
      </div>
    </div>
  </div>
  <div class="overlay hidden" id="room-settings-overlay">
    <div class="panel">
      <h2>Room setup</h2>
      <div class="choice-grid" style="grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));">
        <div class="card">
          <div class="name">Chaser character</div>
          <label for="room-char" class="speed">Pick character</label><br />
          <select id="room-char" style="padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.1); background:rgba(255,255,255,0.05); color:var(--text); width:100%;">
            <option value="snail">üêå Snail</option>
            <option value="frog">üê∏ Frog</option>
            <option value="tiger">üêØ Tiger</option>
            <option value="ninja">ü•∑üèª Ninja</option>
          </select>
        </div>
        <div class="card">
          <div class="name">Chaser speed</div>
          <label for="room-speed" class="speed">Speed (km/h)</label><br />
          <input id="room-speed" type="number" min="0" max="10000" step="1" value="2" style="width: 130px;" />
        </div>
        <div class="card">
          <div class="name">Spawn</div>
          <label for="room-radius" class="speed">Max radius (m)</label><br />
          <input id="room-radius" type="number" min="100" max="50000" step="100" value="5000" style="width: 130px;" />
          <div style="margin-top:8px;">
            <label><input id="room-random" type="checkbox" /> Randomize within radius</label>
          </div>
        </div>
      </div>
      <div class="start-row">
        <p class="status">Confirm to create or update room settings.</p>
        <div style="display:flex; gap:10px;">
          <button id="room-settings-cancel" class="btn" type="button">Cancel</button>
          <button id="room-settings-apply" class="start-btn" type="button">Confirm</button>
        </div>
      </div>
    </div>
  </div>
  <div id="message" aria-live="polite">Enable location services to see your position.</div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    const WS_URL = "wss://killer-snail.onrender.com";

    const statusEl = document.getElementById("status");
    const pillEl = document.getElementById("pill");
    const messageEl = document.getElementById("message");
    const speedInput = document.getElementById("speed");
    const speedValue = document.getElementById("speed-value");
    const restartBtn = document.getElementById("restart-snail");
    const openSelectionBtn = document.getElementById("open-selection");
    const openSettingsBtn = document.getElementById("open-settings");
    const overlay = document.getElementById("start-overlay");
    const loseOverlay = document.getElementById("lose-overlay");
    const resetGameBtn = document.getElementById("reset-game");
    const settingsOverlay = document.getElementById("settings-overlay");
    const roomSettingsOverlay = document.getElementById("room-settings-overlay");
    const roomSettingsApply = document.getElementById("room-settings-apply");
    const roomSettingsCancel = document.getElementById("room-settings-cancel");
    const roomCharSelect = document.getElementById("room-char");
    const roomSpeedInput = document.getElementById("room-speed");
    const roomRadiusInput = document.getElementById("room-radius");
    const roomRandomToggle = document.getElementById("room-random");
    const godToggle = document.getElementById("god-toggle");
    const godSpeedInput = document.getElementById("god-speed");
    const spawnRadiusInput = document.getElementById("spawn-radius");
    const randomSpawnToggle = document.getElementById("random-spawn");
    const settingsApply = document.getElementById("settings-apply");
    const settingsCancel = document.getElementById("settings-cancel");
    const playerNameInput = document.getElementById("player-name");
    const modeSoloBtn = document.getElementById("mode-solo");
    const modeRoomBtn = document.getElementById("mode-room");
    const roomStatus = document.getElementById("room-status");
    const modeRow = document.getElementById("mode-row");
    const soloSection = document.getElementById("solo-section");
    const roomSection = document.getElementById("room-section");
    const generateRoomBtn = document.getElementById("generate-room");
    const roomCodeDisplay = document.getElementById("room-code-display");
    const joinCodeInput = document.getElementById("join-code");
    const joinRoomBtn = document.getElementById("join-room");
    const roomPill = document.getElementById("room-pill");
    const leaveRoomBtn = document.getElementById("leave-room");
    const roomStartRow = document.getElementById("room-start-row");
    const roomStartBtn = document.getElementById("room-start-btn");
    const refreshRoomsBtn = document.getElementById("refresh-rooms");
    const roomsList = document.getElementById("rooms-list");
    const characterGrid = document.getElementById("character-grid");
    const startBtn = document.getElementById("start-btn");
    const selectedLabel = document.getElementById("selected-label");

    let userCoords = null;
    let snailCoords = null;
    let userMarker = null;
    let snailMarker = null;
    let accuracyCircle = null;
    let speedKmh = parseFloat(speedInput.value);
    let selectedCharId = "snail";
    let gameStarted = false;
    let selectedEmoji = "üêå";
    let config = {
      godMode: false,
      godSpeed: 100,
      spawnRadius: 5000,
      randomSpawn: false,
    };
    let forceRespawn = false;
    let chaseStartedAt = null;
    let lastStepAt = null;
    let distanceTraveled = 0;
    let gameMode = null; // null | "solo" | "room"
    let roomCode = "";
    let roomLocked = false;
    let playerNickname = "You";
    let ws = null;
    let isHost = false;
    let myPlayerId = null;
    let otherMarkers = new Map();
    let latestRoomState = null;
    let wsStatus = "disconnected";
    let wsReconnectTimer = null;

    const map = L.map("map", { zoomControl: true, worldCopyJump: true });
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: '&copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors'
    }).addTo(map);
    map.setView([0, 0], 2);

    function makePlayerIcon() {
      return L.divIcon({
        className: "snail-icon",
        html: "üßå",
        iconSize: [36, 36],
        iconAnchor: [18, 28],
        popupAnchor: [0, -26]
      });
    }

    const characters = [
      { id: "snail", emoji: "üêå", name: "Snail", speed: 0.048, min: 0.048, max: 0.048, adjustable: false },
      { id: "frog", emoji: "üê∏", name: "Frog", speed: 1, min: 1, max: 1, adjustable: false },
      { id: "tiger", emoji: "üêØ", name: "Tiger", speed: 50, min: 50, max: 50, adjustable: false },
      { id: "ninja", emoji: "ü•∑üèª", name: "Ninja", speed: 5, min: 2, max: 25, adjustable: true },
    ];
    function charEmoji(id) {
      const c = characters.find((x) => x.id === id);
      return c ? c.emoji : selectedEmoji;
    }

    function setStatus(text, pill) {
      statusEl.textContent = text;
      pillEl.textContent = pill;
    }

    function updateMessage(text) {
      messageEl.textContent = text;
    }

    function setWsStatus(text) {
      wsStatus = text;
      roomPill.textContent = roomCode ? `Room: ${roomCode} (${text})` : `WS: ${text}`;
      roomPill.style.display = gameMode === "room" ? "inline-block" : "none";
    }

    function setRoomStatus() {
      if (!gameMode) {
        roomStatus.textContent = "Choose a mode";
        modeRow.style.display = "flex";
        soloSection.style.display = "none";
        roomSection.style.display = "none";
        roomPill.style.display = "none";
        restartBtn.style.display = "inline-block";
        openSelectionBtn.style.display = "inline-block";
        openSettingsBtn.style.display = "inline-block";
        restartBtn.disabled = false;
        openSelectionBtn.disabled = false;
        leaveRoomBtn.style.display = "none";
        godToggle.disabled = false;
        return;
      }
      modeRow.style.display = "none";
      roomStatus.textContent = gameMode === "solo" ? "Solo mode" : `Room mode${roomLocked ? " (locked)" : ""}`;
      soloSection.style.display = gameMode === "solo" ? "block" : "none";
      roomSection.style.display = gameMode === "room" ? "block" : "none";
      roomPill.style.display = gameMode === "room" && roomCode ? "inline-block" : "none";
      roomPill.textContent = roomCode ? `Room: ${roomCode}` : "Room: ----";
      if (gameMode === "room") {
        restartBtn.style.display = "none";
        openSelectionBtn.style.display = "none";
        openSettingsBtn.style.display = "none";
        roomStartRow.style.display = isHost ? "flex" : "none";
      } else {
        restartBtn.style.display = "inline-block";
        openSelectionBtn.style.display = "inline-block";
        openSettingsBtn.style.display = "inline-block";
        roomStartRow.style.display = "none";
      }
      restartBtn.disabled = roomLocked;
      openSelectionBtn.disabled = roomLocked;
      leaveRoomBtn.style.display = gameMode === "room" ? "inline-block" : "none";
      if (gameMode === "room") {
        godToggle.checked = false;
        godToggle.disabled = true;
      } else {
        godToggle.disabled = false;
      }
    }

    function generateRoomCode() {
      const chars = "ABCDEFGHJKMNPQRSTUVWXYZ23456789";
      let code = "";
      for (let i = 0; i < 6; i++) {
        code += chars[Math.floor(Math.random() * chars.length)];
      }
      return code;
    }

    function formatElapsed() {
      if (!chaseStartedAt) return "0s";
      const elapsedMs = Date.now() - chaseStartedAt;
      const totalSeconds = Math.max(0, Math.floor(elapsedMs / 1000));
      const mins = Math.floor(totalSeconds / 60);
      const secs = totalSeconds % 60;
      return `${mins}:${secs.toString().padStart(2, "0")}`;
    }

    function updatePlayerLabel(marker) {
      if (!marker) return;
      marker.bindPopup(playerNickname || "You");
      marker.unbindTooltip();
      marker.bindTooltip(playerNickname || "You", { permanent: true, direction: "top", offset: [0, -10] });
    }

    function startChase() {
      if (!gameMode) {
        alert("Choose Solo or Multiplayer first.");
        return;
      }
      if (gameMode === "room" && roomLocked) {
        alert("This room can‚Äôt be restarted. Create or join a new room.");
        return;
      }
      if (gameMode === "room" && !roomCode) {
        alert("Create or join a room first to get a code.");
        return;
      }
      loseOverlay.classList.add("hidden");
      gameStarted = true;
      if (gameMode === "solo") {
        if (forceRespawn || !snailCoords || !snailMarker) {
          if (snailMarker) {
            map.removeLayer(snailMarker);
            snailMarker = null;
          }
          snailCoords = null;
          placeSnailRandom();
        } else if (snailMarker) {
          snailMarker.setIcon(makeEmojiIcon(selectedEmoji));
        }
      } else {
        ensureSocket();
        if (isHost) {
          sendWs({ type: "start", code: roomCode });
        }
      }
      overlay.classList.add("hidden");
      forceRespawn = false;
      chaseStartedAt = Date.now();
      lastStepAt = Date.now();
      distanceTraveled = 0;
      if (gameMode === "room") {
        roomLocked = true;
        setRoomStatus();
      }
    }

    function setCharacter(id) {
      const choice = characters.find(c => c.id === id) || characters[0];
      selectedCharId = choice.id;
      selectedEmoji = choice.emoji;
      speedInput.min = choice.min;
      speedInput.max = choice.max;
      speedInput.step = choice.max > 100 ? 10 : 0.5;
      speedInput.value = choice.speed;
      speedInput.disabled = !choice.adjustable || config.godMode;
      speedKmh = config.godMode ? config.godSpeed : (choice.adjustable ? parseFloat(speedInput.value) : choice.speed);
      speedValue.textContent = config.godMode ? config.godSpeed.toFixed(1) : (choice.adjustable ? speedKmh.toFixed(1) : speedKmh.toString());
      selectedLabel.textContent = `Selected: ${choice.name} ¬∑ ${choice.adjustable ? `${choice.min}‚Äì${choice.max} km/h` : `${choice.speed} km/h`}`;
      document.querySelectorAll(".card").forEach(card => {
        card.classList.toggle("active", card.dataset.id === id);
      });
      if (snailMarker) {
        snailMarker.setIcon(makeEmojiIcon(selectedEmoji));
      }
    }

    function makeEmojiIcon(emoji) {
      return L.divIcon({
        className: "snail-icon",
        html: emoji,
        iconSize: [36, 36],
        iconAnchor: [18, 28],
        popupAnchor: [0, -26]
      });
    }

    function resetMenu() {
      gameMode = null;
      roomLocked = false;
      roomCode = "";
      roomCodeDisplay.textContent = "----";
      forceRespawn = false;
      chaseStartedAt = null;
      lastStepAt = null;
      distanceTraveled = 0;
      isHost = false;
      if (snailMarker) {
        map.removeLayer(snailMarker);
        snailMarker = null;
      }
      snailCoords = null;
      for (const m of otherMarkers.values()) {
        map.removeLayer(m);
      }
      otherMarkers.clear();
      setRoomStatus();
      updateMessage("Choose a mode to begin.");
    }

    function askNickname(defaultName = "You") {
      const input = prompt("Enter your nickname:", playerNickname || defaultName);
      if (input === null) return null;
      const trimmed = input.trim();
      if (trimmed === "") return defaultName;
      return trimmed.slice(0, 24);
    }

    function makePlayerEmojiIcon(emoji) {
      return L.divIcon({
        className: "snail-icon",
        html: emoji || "üßå",
        iconSize: [32, 32],
        iconAnchor: [16, 24],
        popupAnchor: [0, -20]
      });
    }

    function ensureSocket() {
      if (ws && ws.readyState === WebSocket.OPEN) return ws;
      if (ws) {
        try { ws.close(); } catch {}
        ws = null;
      }
      setWsStatus("connecting");
      ws = new WebSocket(WS_URL);
      ws.onopen = () => {
        console.log("WS connected");
        setWsStatus("connected");
        if (wsReconnectTimer) {
          clearTimeout(wsReconnectTimer);
          wsReconnectTimer = null;
        }
        // Resubscribe/join room after reconnect
        if (gameMode === "room" && roomCode) {
          sendWs({
            type: "join_room",
            code: roomCode,
            name: playerNickname,
            emoji: selectedEmoji,
            lat: userCoords?.[0] ?? null,
            lng: userCoords?.[1] ?? null
          });
        }
      };
      ws.onmessage = (evt) => {
        try {
          const msg = JSON.parse(evt.data);
          handleWsMessage(msg);
        } catch (e) {
          console.warn("WS parse error", e);
        }
      };
      ws.onclose = (evt) => {
        console.log("WS closed", evt.code, evt.reason);
        setWsStatus("disconnected");
        ws = null;
        if (gameMode === "room" && !wsReconnectTimer) {
          wsReconnectTimer = setTimeout(() => {
            wsReconnectTimer = null;
            ensureSocket();
          }, 3000);
        }
      };
      ws.onerror = (e) => {
        console.error("WS error", e);
        setWsStatus("error");
      };
      return ws;
    }

    function sendWs(msg) {
      const sock = ensureSocket();
      if (sock.readyState === WebSocket.OPEN) {
        sock.send(JSON.stringify(msg));
      } else {
        sock.addEventListener(
          "open",
          () => {
            sock.send(JSON.stringify(msg));
          },
          { once: true }
        );
      }
    }

    function handleWsMessage(msg) {
      if (msg.type === "error") {
        alert(msg.message || "Server error");
        if (msg.message && msg.message.toLowerCase().includes("room already exists") && isHost && gameMode === "room") {
          roomCode = generateRoomCode();
          roomCodeDisplay.textContent = roomCode;
          sendWs({
            type: "create_room",
            code: roomCode,
            name: playerNickname,
            emoji: selectedEmoji,
            lat: userCoords?.[0] ?? null,
            lng: userCoords?.[1] ?? null,
            settings: {
              character: selectedCharId,
              speedKmh: config.godSpeed || speedKmh,
              spawnRadius: config.spawnRadius,
              randomSpawn: config.randomSpawn,
            },
          });
        }
        return;
      }
      if (msg.type === "room_created") {
        roomCode = msg.code;
        myPlayerId = msg.playerId || myPlayerId;
        roomCodeDisplay.textContent = roomCode;
        setRoomStatus();
        updateMessage(`Room created. Share code: ${roomCode}`);
        setWsStatus("connected");
        return;
      }
      if (msg.type === "room_joined") {
        roomCode = msg.code;
        myPlayerId = msg.playerId || myPlayerId;
        roomCodeDisplay.textContent = roomCode;
        setRoomStatus();
        updateMessage(`Joined room ${roomCode}. Share this code with others.`);
        setWsStatus("connected");
        return;
      }
      if (msg.type === "state") {
        latestRoomState = msg;
        roomCode = msg.code;
        roomLocked = msg.locked;
        gameStarted = !!msg.running;
        setRoomStatus();
        if (msg.settings?.character) {
          selectedEmoji = charEmoji(msg.settings.character);
        }
        if (msg.chaser) {
          snailCoords = [msg.chaser.lat, msg.chaser.lng];
          if (!snailMarker) {
            snailMarker = L.marker(snailCoords, { icon: makeEmojiIcon(selectedEmoji) }).addTo(map).bindPopup("Chaser");
          } else {
            snailMarker.setLatLng(snailCoords).setIcon(makeEmojiIcon(selectedEmoji));
          }
        }
        // Update other players
        const seen = new Set();
        if (Array.isArray(msg.players)) {
          msg.players.forEach((p) => {
            seen.add(p.id);
            if (p.id === myPlayerId) return;
            if (p.lat == null || p.lng == null) return;
            let m = otherMarkers.get(p.id);
            if (!m) {
              m = L.marker([p.lat, p.lng], { icon: makePlayerEmojiIcon(p.emoji) })
                .addTo(map)
                .bindPopup(p.name || "Player");
              m.bindTooltip(p.name || "Player", { permanent: true, direction: "top", offset: [0, -10] });
              otherMarkers.set(p.id, m);
            } else {
              m.setLatLng([p.lat, p.lng]).setIcon(makePlayerEmojiIcon(p.emoji));
              m.bindPopup(p.name || "Player");
              m.bindTooltip(p.name || "Player", { permanent: true, direction: "top", offset: [0, -10] });
            }
          });
        }
        for (const [id, marker] of otherMarkers.entries()) {
          if (!seen.has(id)) {
            map.removeLayer(marker);
            otherMarkers.delete(id);
          }
        }
        // Handle end
        if (msg.caughtId && msg.caughtId === myPlayerId) {
          gameStarted = false;
          loseOverlay.classList.remove("hidden");
          setStatus("Caught", "Arrived");
          const elapsed = msg.startedAt ? `${Math.floor((Date.now() - msg.startedAt) / 60000)}:${Math.floor(((Date.now() - msg.startedAt) / 1000) % 60).toString().padStart(2, "0")}` : "0:00";
          const traveledKm = (msg.distanceTraveled / 1000).toFixed(3);
          document.getElementById("lose-details").textContent =
            `The chaser caught you. Time: ${elapsed} ¬∑ Distance traveled: ${traveledKm} km`;
        } else if (!msg.running && msg.locked) {
          gameStarted = false;
          setStatus("Idle", "Idle");
          updateMessage("Room ended. Create/join again to restart.");
        }
        return;
      }
      if (msg.type === "rooms") {
        roomsList.innerHTML = "";
        if (!Array.isArray(msg.rooms) || msg.rooms.length === 0) {
          roomsList.innerHTML = "<p class='status'>No rooms found.</p>";
          return;
        }
        msg.rooms.forEach((r) => {
          const card = document.createElement("button");
          card.type = "button";
          card.className = "card";
          card.innerHTML = `
            <div class="name">${r.name || "Room"}</div>
            <div class="speed">${r.players || 0}/10 ${r.running ? "running" : "idle"}</div>
            <div class="status">Code: ${r.code}</div>
          `;
          card.addEventListener("click", () => {
            joinCodeInput.value = r.code;
            updateMessage(`Selected room ${r.name || r.code}. Enter code as password to join.`);
          });
          roomsList.appendChild(card);
        });
        return;
      }
    }

    function buildCharacterGrid() {
      characterGrid.innerHTML = "";
      characters.forEach(({ id, emoji, name, speed, adjustable, min, max }) => {
        const card = document.createElement("button");
        card.type = "button";
        card.className = "card";
        card.dataset.id = id;
        card.innerHTML = `
          <span class="emoji">${emoji}</span>
          <div class="name">${name}</div>
          <div class="speed">${adjustable ? `${min}‚Äì${max} km/h (you choose)` : `${speed} km/h`}</div>
        `;
        card.addEventListener("click", () => setCharacter(id));
        characterGrid.appendChild(card);
      });
      setCharacter(selectedCharId);
    }

    function currentSpeedMps() {
      return speedKmh / 3.6;
    }

    function randomOffsetPoint(lat, lng, distanceMeters) {
      const R = 6371000;
      const bearing = Math.random() * 2 * Math.PI;
      const delta = distanceMeters / R;
      const œÜ1 = lat * (Math.PI / 180);
      const Œª1 = lng * (Math.PI / 180);

      const œÜ2 = Math.asin(Math.sin(œÜ1) * Math.cos(delta) + Math.cos(œÜ1) * Math.sin(delta) * Math.cos(bearing));
      const Œª2 = Œª1 + Math.atan2(
        Math.sin(bearing) * Math.sin(delta) * Math.cos(œÜ1),
        Math.cos(delta) - Math.sin(œÜ1) * Math.sin(œÜ2)
      );

      const newLat = œÜ2 * (180 / Math.PI);
      const newLng = ((Œª2 * (180 / Math.PI) + 540) % 360) - 180;
      return [newLat, newLng];
    }

    function distanceMeters(a, b) {
      const toRad = d => d * (Math.PI / 180);
      const R = 6371000;
      const dLat = toRad(b[0] - a[0]);
      const dLng = toRad(b[1] - a[1]);
      const lat1 = toRad(a[0]);
      const lat2 = toRad(b[0]);
      const h = Math.sin(dLat / 2) ** 2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLng / 2) ** 2;
      return 2 * R * Math.asin(Math.min(1, Math.sqrt(h)));
    }

    function moveTowards(start, target, maxStepMeters) {
      const dist = distanceMeters(start, target);
      if (dist <= maxStepMeters || dist === 0) return target;
      const ratio = maxStepMeters / dist;
      const lat = start[0] + (target[0] - start[0]) * ratio;
      const lng = start[1] + (target[1] - start[1]) * ratio;
      return [lat, lng];
    }

    function onLocationSuccess(position) {
      const { latitude, longitude, accuracy } = position.coords;
      userCoords = [latitude, longitude];

      if (!userMarker) {
        userMarker = L.marker(userCoords, { icon: makePlayerIcon() })
          .addTo(map)
          .bindPopup(playerNickname || "You")
          .openPopup();
        userMarker.bindTooltip(playerNickname || "You", { permanent: true, direction: "top", offset: [0, -10] });
      } else {
        userMarker.setLatLng(userCoords).setIcon(makePlayerIcon());
        updatePlayerLabel(userMarker);
      }

      if (accuracy) {
        if (accuracyCircle) {
          accuracyCircle.setLatLng(userCoords).setRadius(accuracy);
        } else {
          accuracyCircle = L.circle(userCoords, { radius: accuracy, color: "#22c55e", weight: 2, fillOpacity: 0.08 }).addTo(map);
        }
      }

      if (gameStarted && !snailCoords) {
        placeSnailRandom();
      }
      if (gameMode === "room" && roomCode) {
        sendWs({ type: "loc", code: roomCode, lat: userCoords[0], lng: userCoords[1] });
      }
    }

    function onLocationError(err) {
      setStatus("Unable to fetch location", "Error");
      updateMessage(err.message || "Location access denied. Please enable permission and refresh.");
    }

    function placeSnailRandom() {
      if (!userCoords) {
        updateMessage("Waiting for your location before placing the chaser.");
        return;
      }
      const radius = Math.max(0, config.spawnRadius || 0);
      const distance = config.randomSpawn ? Math.random() * radius : radius;
      snailCoords = randomOffsetPoint(userCoords[0], userCoords[1], distance);
      if (!snailMarker) {
        snailMarker = L.marker(snailCoords, { icon: makeEmojiIcon(selectedEmoji) }).addTo(map).bindPopup("Chaser (moving)");
      } else {
        snailMarker.setLatLng(snailCoords).setIcon(makeEmojiIcon(selectedEmoji)).bindPopup("Chaser (moving)");
      }
      map.fitBounds(L.latLngBounds([userCoords, snailCoords]), { padding: [40, 40] });
    }

    function stepChase() {
      if (!gameMode || !gameStarted) {
        lastStepAt = null;
        return;
      }
      if (gameMode === "room") {
        if (snailCoords && userCoords) {
          const dist = distanceMeters(snailCoords, userCoords);
          setStatus("Room chase", dist > 3 ? "Live" : "Arrived");
          const elapsed = latestRoomState?.startedAt
            ? `${Math.floor((Date.now() - latestRoomState.startedAt) / 60000)}:${Math.floor(((Date.now() - latestRoomState.startedAt) / 1000) % 60).toString().padStart(2, "0")}`
            : formatElapsed();
          const traveled = latestRoomState?.distanceTraveled ?? distanceTraveled;
          const srvSpeed = latestRoomState?.settings?.speedKmh ?? speedKmh;
          updateMessage(`Dist: ${dist.toFixed(1)} m ¬∑ Speed: ${srvSpeed.toFixed(1)} km/h ¬∑ Time: ${elapsed} ¬∑ Traveled: ${(traveled / 1000).toFixed(3)} km`);
        }
        return;
      }
      if (!userCoords || !snailCoords || !snailMarker) {
        lastStepAt = Date.now();
        return;
      }
      const now = Date.now();
      if (!lastStepAt) lastStepAt = now;
      const dtSeconds = Math.min(10, (now - lastStepAt) / 1000); // cap catch-up
      lastStepAt = now;
      const next = moveTowards(snailCoords, userCoords, currentSpeedMps() * dtSeconds);
      const stepDist = distanceMeters(snailCoords, next);
      distanceTraveled += stepDist;
      snailCoords = next;
      snailMarker.setLatLng(next);
      const dist = distanceMeters(next, userCoords);
      const status = dist > 3 ? "Live" : "Arrived";
      setStatus("Location locked", status);
      updateMessage(
        `Dist: ${dist.toFixed(1)} m ¬∑ Speed: ${speedKmh.toFixed(1)} km/h ¬∑ Time: ${formatElapsed()}`
      );
      if (status !== "Live") {
        snailMarker.bindPopup("Chaser (arrived)").openPopup();
        userMarker?.openPopup();
        gameStarted = false;
        loseOverlay.classList.remove("hidden");
        forceRespawn = true;
        lastStepAt = null;
        const elapsed = formatElapsed();
        const traveledKm = (distanceTraveled / 1000).toFixed(3);
        document.getElementById("lose-details").textContent =
          `The chaser caught you. Time: ${elapsed} ¬∑ Distance traveled: ${traveledKm} km`;
      }
    }

    function init() {
      if (!navigator.geolocation) {
        setStatus("Geolocation not supported", "Error");
        updateMessage("This browser does not support geolocation.");
        return;
      }

      setStatus("Requesting location‚Ä¶", "Pending");

      speedInput.addEventListener("input", () => {
        if (config.godMode) return;
        speedKmh = parseFloat(speedInput.value);
        speedValue.textContent = speedKmh.toFixed(1);
      });

      restartBtn.addEventListener("click", () => {
        if (roomLocked) {
          alert("Room run is locked. Create or join a new room to play again.");
          return;
        }
        const ok = window.confirm("Reset the chaser to a new random spot?");
        if (ok) {
          placeSnailRandom();
        }
      });

      openSelectionBtn.addEventListener("click", () => {
        if (roomLocked) {
          alert("Room run is locked. Create or join a new room to play again.");
          return;
        }
        const ok = window.confirm("Going to the menu will end this chase. Continue?");
        if (!ok) return;
        gameStarted = false;
        loseOverlay.classList.add("hidden");
        overlay.classList.remove("hidden");
        setStatus("Selection", "Idle");
        resetMenu();
      });

      openSettingsBtn.addEventListener("click", () => {
        settingsOverlay.classList.remove("hidden");
        godToggle.checked = config.godMode;
        godSpeedInput.value = config.godSpeed;
        spawnRadiusInput.value = config.spawnRadius;
        randomSpawnToggle.checked = config.randomSpawn;
      });

      settingsCancel.addEventListener("click", () => {
        settingsOverlay.classList.add("hidden");
      });

      settingsApply.addEventListener("click", () => {
        config.godMode = godToggle.checked;
        config.godSpeed = Math.min(10000, Math.max(0, parseFloat(godSpeedInput.value) || 0));
        config.spawnRadius = Math.min(50000, Math.max(100, parseFloat(spawnRadiusInput.value) || 0));
        config.randomSpawn = randomSpawnToggle.checked;
        godSpeedInput.value = config.godSpeed;
        spawnRadiusInput.value = config.spawnRadius;
        settingsOverlay.classList.add("hidden");
        setCharacter(selectedCharId); // reapply speeds/controls
        if (!gameStarted) {
          updateMessage("Settings applied. Start the chase!");
        }
        const nameVal = playerNameInput.value.trim();
        if (nameVal !== "") {
          playerNickname = nameVal.slice(0, 24);
        } else {
          playerNickname = "You";
        }
        updatePlayerLabel(userMarker);
      });

      modeSoloBtn.addEventListener("click", () => {
        gameMode = "solo";
        roomLocked = false;
        roomCode = "";
        setRoomStatus();
        setCharacter(selectedCharId);
        forceRespawn = true;
        updateMessage("Solo mode selected. Pick a chaser to start.");
      });

      modeRoomBtn.addEventListener("click", () => {
        gameMode = "room";
        roomLocked = false;
        setRoomStatus();
        updateMessage("Multiplayer selected. Create or join a room.");
      });

      generateRoomBtn.addEventListener("click", () => {
        roomCharSelect.value = selectedCharId;
        roomSpeedInput.value = speedKmh;
        roomRadiusInput.value = config.spawnRadius;
        roomRandomToggle.checked = config.randomSpawn;
        roomSettingsOverlay.classList.remove("hidden");
      });

      joinRoomBtn.addEventListener("click", () => {
        const code = joinCodeInput.value.trim().toUpperCase();
        if (!code) {
          alert("Enter a room code to join.");
          return;
        }
        const nick = askNickname(playerNickname || "You");
        if (nick === null) return;
        playerNickname = nick;
        updatePlayerLabel(userMarker);
        gameMode = "room";
        isHost = false;
        roomCode = code.slice(0, 8);
        roomCodeDisplay.textContent = roomCode;
        setRoomStatus();
        updateMessage(`Joined room ${roomCode}. Share this code with others.`);
        config.godMode = false;
        godToggle.checked = false;
        godToggle.disabled = true;
        ensureSocket();
        sendWs({
          type: "join_room",
          code: roomCode,
          name: playerNickname,
          emoji: selectedEmoji,
          lat: userCoords?.[0] ?? null,
          lng: userCoords?.[1] ?? null,
        });
      });

      roomSettingsCancel.addEventListener("click", () => {
        roomSettingsOverlay.classList.add("hidden");
      });

      roomCharSelect.addEventListener("change", () => {
        const cid = roomCharSelect.value;
        const fixed = characters.find(c => c.id === cid);
        if (cid === "ninja") {
          roomSpeedInput.disabled = false;
        } else {
          roomSpeedInput.disabled = true;
          roomSpeedInput.value = fixed ? fixed.speed : 2;
        }
      });

      roomSettingsApply.addEventListener("click", () => {
        const nick = askNickname(playerNickname || "You");
        if (nick === null) return;
        playerNickname = nick;
        updatePlayerLabel(userMarker);
        const chosenId = roomCharSelect.value;
        const chosenChar = characters.find(c => c.id === chosenId) || characters[0];
        setCharacter(chosenId);
        config.godMode = false;
        let chosenSpeed = chosenChar.speed;
        if (chosenId === "ninja") {
          chosenSpeed = Math.min(10000, Math.max(chosenChar.min, parseFloat(roomSpeedInput.value) || chosenChar.speed));
        }
        config.godSpeed = chosenSpeed;
        config.spawnRadius = Math.min(50000, Math.max(100, parseFloat(roomRadiusInput.value) || 0));
        config.randomSpawn = roomRandomToggle.checked;
        godToggle.checked = false;
        godToggle.disabled = true;
        godSpeedInput.value = config.godSpeed;
        spawnRadiusInput.value = config.spawnRadius;
        randomSpawnToggle.checked = config.randomSpawn;
        roomCode = generateRoomCode();
        roomCodeDisplay.textContent = roomCode;
        gameMode = "room";
        roomLocked = false;
        isHost = true;
        setRoomStatus();
        updateMessage(`Room created. Share code: ${roomCode}`);
        roomSettingsOverlay.classList.add("hidden");
        speedKmh = config.godSpeed;
        speedInput.value = speedKmh;
        speedValue.textContent = speedKmh.toFixed(1);
        forceRespawn = true;
        ensureSocket();
        isHost = true;
        sendWs({
          type: "create_room",
          code: roomCode,
          name: playerNickname,
          emoji: selectedEmoji,
          lat: userCoords?.[0] ?? null,
          lng: userCoords?.[1] ?? null,
          settings: {
            character: chosenId,
            speedKmh: chosenSpeed,
            spawnRadius: config.spawnRadius,
            randomSpawn: config.randomSpawn,
          },
          roomName: `${playerNickname}'s Room`,
        });
        // Host must press start; show start button
        roomStartRow.style.display = "flex";
      });

      leaveRoomBtn.addEventListener("click", () => {
        resetMenu();
        playerNickname = "You";
        myPlayerId = null;
        isHost = false;
        overlay.classList.remove("hidden");
        loseOverlay.classList.add("hidden");
        setStatus("Selection", "Idle");
        updateMessage("Left room. Solo mode.");
      });

      resetGameBtn.addEventListener("click", () => {
        gameStarted = false;
        loseOverlay.classList.add("hidden");
        overlay.classList.remove("hidden");
        if (snailMarker) {
          map.removeLayer(snailMarker);
          snailMarker = null;
        }
        snailCoords = null;
        updateMessage("Pick a character to start chasing.");
        setStatus("Selection", "Idle");
        forceRespawn = true;
        chaseStartedAt = null;
        lastStepAt = null;
        distanceTraveled = 0;
      });

      startBtn.addEventListener("click", startChase);

      roomStartBtn.addEventListener("click", () => {
        if (!isHost) return;
        startChase();
      });

      refreshRoomsBtn.addEventListener("click", () => {
        ensureSocket();
        sendWs({ type: "list_rooms" });
      });

      characterGrid.addEventListener("click", (e) => {
        const card = e.target.closest(".card");
        if (!card || gameMode !== "solo") return;
        const cid = card.dataset.id;
        setCharacter(cid);
        forceRespawn = true;
        updateMessage("Chaser selected. Press Start to begin.");
      });

      buildCharacterGrid();

      navigator.geolocation.watchPosition(
        onLocationSuccess,
        onLocationError,
        { enableHighAccuracy: true, timeout: 12000, maximumAge: 0 }
      );
      setInterval(stepChase, 1000);
      setInterval(() => {
        if (gameMode === "room" && roomCode && userCoords) {
          sendWs({ type: "loc", code: roomCode, lat: userCoords[0], lng: userCoords[1] });
        }
      }, 2000);
    }

    init();
  </script>
</body>
</html>
